# MIT License
#
# Copyright 2022 New York University Abu Dhabi
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import argparse
import os
import sys
from collections import Counter
from math import log
import pickle
import re

from tqdm import tqdm
import pandas as pd

file_path = os.path.abspath(__file__).split('/')
package_path = '/'.join(file_path[:len(file_path) - 1 - file_path[::-1].index('camel_morph')])
sys.path.insert(0, package_path)
sys.path.insert(0, './camel_morph/camel_tools')

from camel_morph.eval.evaluate_camel_morph import _preprocess_magold_data, _load_analysis
from camel_morph.sandbox.sync_magold import synchronize

from camel_tools.utils.charmap import CharMapper
from camel_tools.morphology.utils import strip_lex

ar2bw = CharMapper.builtin_mapper('ar2bw')
bw2ar = CharMapper.builtin_mapper('bw2ar')

parser = argparse.ArgumentParser()
parser.add_argument("-magold_calima_path", default=None,
                    type=str, help="Path of the file containing the MSA MAGOLD data synched with the analyses of the Calima DB. If not provided, then the file will be generated by the sync code, but this will take a long time.")
parser.add_argument("-magold_camel_path", default=None,
                    type=str, help="Path of the file containing the MSA MAGOLD data synched with the analyses of the Camel Morph DB. If not provided, then the file will be generated by the sync code, but this will take a long time.")
parser.add_argument("-magold", default=None,
                        type=str, help="Path of the MSA MAGOLD data containing the synched PATB (LDC) analyses with the SAMA/MADA analyses.")
parser.add_argument("-db_calima", default=None,
                    type=str, help="Path of the Calima DB to be synced with the MAGOLD data.")
parser.add_argument("-db_camel", default=None,
                    type=str, help="Path of the Calima DB to be synced with the MAGOLD data.")
parser.add_argument("-ext", default=None,
                    type=str, help="Extension to append to the name of the original MAGOLD file for the output MAGOLD file name.")
parser.add_argument("-output_dir_magold_calima", default='',
                    type=str, help="Directory to output the resulting Calima synced MAGOLD file to.")
parser.add_argument("-output_dir_magold_camel", default='',
                    type=str, help="Directory to output the resulting Camel synced MAGOLD file to.")
parser.add_argument("-logprob_calima", default='logprob_atb_calima.pkl',
                    type=str, help="Name of the pickle file to output the Calima logprob dictionary to (extracted using the Calima synched MAGOLD data).")
parser.add_argument("-logprob_camel", default='logprob_atb_camel.pkl',
                    type=str, help="Name of the pickle file to output the Camel Morph logprob dictionary to (extracted using the Camel Morph synched MAGOLD data).")
parser.add_argument("-load_logprob", action='store_true', default=False,
                    help="Whether to load logprob from the (previously) computed dictionaries, or compute them again. This is for debugging purposes.")
parser.add_argument("-generate_debug_analysis", action='store_true', default=False,
                    help="Generate a sheet to look at the synced Camel and Calima lemmas.")
parser.add_argument("-output_dir_debug", default='scratch_files/logprob_debugging',
                    type=str, help="Path of the directory to output evaluation results.")
args, _ = parser.parse_known_args()

EXCEPTION_MAPPING = {
    'Allh': 'All~a`h'
}

def get_logprob_dict(analyses):
    feat_freq = {}
    for feat in ['lex', 'pos_lex']:
        feat_freq_ = Counter()
        feat_freq_.update([
            tuple(analysis[feat_]
                if feat_ != 'lex' else _preprocess_lex(analysis[feat_])
                for feat_ in feat.split('_'))
            for analysis in analyses])
        feat_freq[feat] = feat_freq_

    logprob = {}
    for feat in ['lex', 'pos_lex']:
        feat_freq_ = feat_freq[feat]
        total = sum(feat_freq_.values())
        for v, freq in feat_freq_.items():
            logprob.setdefault(feat, {}).setdefault(v, log(freq / total))
            
    return logprob


def _preprocess_lex(lex):
    if lex in EXCEPTION_MAPPING:
        lex = EXCEPTION_MAPPING[lex]
    lex = strip_lex(lex)
    lex = re.sub(r'([^aA])A', r'\1aA', lex)
    return lex


def _get_lemma2analyses(db):
    lemma2analyses = {}
    for lemma, analyses in db.lemma_hash.items():
        if lemma == 'NOAN':
            continue
        lemma_bw = ar2bw(lemma)
        lemma = lemma if '_' in lemma else f'{lemma}_1'
        lemma_preproc = bw2ar(_preprocess_lex(lemma_bw))
        for analysis in analyses:
            if analysis['source'] == 'wiki':
                continue
            lemma2analyses.setdefault(lemma_preproc, []).append(analysis)
    return lemma2analyses


def _get_logprob_from_db(lemma2analyses):
    logprob = {}
    for lemma_ar, analyses in tqdm(lemma2analyses.items()):
        lemma = _preprocess_lex(ar2bw(lemma_ar))
        lex_logprobs_ = sorted(set(float(a['lex_logprob']) for a in analyses))
        logprob.setdefault('lex', {}).setdefault(
            (lemma,), tuple(lex_logprobs_)
            if len(lex_logprobs_) > 1 else lex_logprobs_[0])

        for pos in [a['pos'] for a in analyses]:
            pos_lex_logprobs_ = sorted(
                set(float(a['pos_lex_logprob']) for a in analyses if a['pos'] == pos))
            logprob.setdefault('pos_lex', {}).setdefault(
                (pos, lemma), tuple(pos_lex_logprobs_)
                if len(pos_lex_logprobs_) > 1 else pos_lex_logprobs_[0])

    return logprob


def debug_logprob_camel_morph_magold_sync(logprob_atb_calima, logprob_atb_camel):
    data_path = args.magold_calima_path
    with open(data_path) as f:
        data_magold = f.read()
    data_magold_calima = _preprocess_magold_data(data_magold)

    data_path = args.magold_camel_path
    with open(data_path) as f:
        data_magold = f.read()
    data_magold_camel = _preprocess_magold_data(data_magold)

    sama2systems = {}
    for ex in tqdm(data_magold_calima):
        sama = ex['info']['magold']['starline_prev']
        sama2systems.setdefault(sama, {}).setdefault(
            'calima', ex['info']['magold']['starline'])
    for ex in tqdm(data_magold_camel):
        sama = ex['info']['magold']['starline_prev']
        sama2systems.setdefault(sama, {}).setdefault(
            'camel', ex['info']['magold']['starline'])
    
    counter_sama = Counter(ex['info']['magold']['starline_prev']
                           for ex in data_magold_calima)

    output = []
    for sama, name2analysis in tqdm(sama2systems.items()):
        analysis_calima = name2analysis['calima'].split()
        analysis_calima = analysis_calima[1:]
        analysis_calima = _load_analysis(analysis_calima)
        analysis_camel = name2analysis['camel'].split()
        analysis_camel = analysis_camel[1:]
        analysis_camel = _load_analysis(analysis_camel)
        lex_calima = _preprocess_lex(analysis_calima['lex'])
        lex_camel = _preprocess_lex(analysis_camel['lex'])
        row = (
            analysis_calima['lex'],
            analysis_calima['pos'],
            # logprob_atb_calima['pos_lex'].get((analysis_calima['pos'], lex_calima), 'N/A'),
            # logprob_atb_calima['lex'].get((lex_calima,), 'N/A'),
            analysis_camel['lex'],
            analysis_camel['pos'],
            # logprob_atb_camel['pos_lex'].get((analysis_camel['pos'], lex_camel), 'N/A'),
            # logprob_atb_camel['lex'].get((lex_camel,), 'N/A'),
            counter_sama[sama]
        )
        output.append(row)

    output_ = {}
    for row in output:
        output_.setdefault(row[:-1], 0)
        output_[row[:-1]] += row[-1]
    output = [k + (v,) for k, v in output_.items()]

    header = [
        'lex_calima',
        'pos_calima',
        # 'logprob_pos_lex_calima',
        # 'logprob_atb_calima',
        'lex_camel',
        'pos_camel',
        # 'logprob_pos_lex_camel',
        # 'logprob_atb_camel',
        'count'
    ]

    output_df = pd.DataFrame(set(output), columns=header)
    output_df.to_csv(os.path.join(args.output_dir_debug, 'debug_output.tsv'),
                     sep='\t', index=False)
    pass


def get_loprob(output_path,
               magold_system_synced_path=None,
               magold_original_path=None,
               ext=None,
               db_path=None,
               magold_output_dir=''):
    if magold_system_synced_path is None:
        assert magold_original_path and ext and db_path, (
        '-magold, -ext, and -db must be used to run the sync code. Otherwise, '
        'provide an MAGOLD system-synced path.')
        synchronize(magold_original_path, ext, db_path, magold_output_dir)
    else:
        with open(magold_system_synced_path) as f:
            data_magold = f.read()
    data_magold_system = _preprocess_magold_data(data_magold)
    analyses = [example['analysis'] for example in data_magold_system]
    logprob_atb_system = get_logprob_dict(analyses)
    with open(output_path, 'wb') as f:
        pickle.dump(logprob_atb_system, f)
    return logprob_atb_system


if __name__ == "__main__":
    pickle_calima_output_path = os.path.join(
        args.output_dir_magold_calima, args.logprob_calima)
    pickle_camel_output_path = os.path.join(
        args.output_dir_magold_camel, args.logprob_camel)
    if not args.load_logprob:
        logprob_atb_calima = get_loprob(
            output_path=pickle_calima_output_path,
            magold_system_synced_path=args.magold_calima_path,
            magold_original_path=args.magold,
            ext=args.ext,
            db_path=args.db_calima,
            magold_output_dir=args.output_dir_magold_calima)
        
        logprob_atb_camel = get_loprob(
            output_path=pickle_camel_output_path,
            magold_system_synced_path=args.magold_camel_path,
            magold_original_path=args.magold,
            ext=args.ext,
            db_path=args.db_camel,
            magold_output_dir=args.output_dir_magold_camel)
    else:
        with open(pickle_calima_output_path, 'rb') as f:
            logprob_atb_calima = pickle.load(f)
        with open(pickle_camel_output_path, 'rb') as f:
            logprob_atb_camel = pickle.load(f)

    if args.generate_debug_analysis:
        debug_logprob_camel_morph_magold_sync(
            logprob_atb_calima, logprob_atb_camel)
